import { RscDemoLinks } from "@/components/demo/rsc-demo-links";
import Image from 'next/image';
import Link from 'next/link';
import { ImageSwitch } from '../_components/image-switch.tsx';
import { Notes } from '../_components/notes.tsx';
import { Column, MainSlide, TwoColumns } from '../_components/slide-layouts.tsx';
import RSC1 from './images/rsc1.png';
import RSC2 from './images/rsc2.png';
import RSC3 from './images/rsc3.png';
import RSC4 from './images/rsc4.png';

<TwoColumns>
  <Column className="flex flex-col justify-center items-center gap-4">
  
    # React server components (RSC)
    <RscDemoLinks />
  </Column>

  <Column className="flex flex-row justify-center items-center">
    <ImageSwitch images={[
      (<Image key={RSC1.src} src={RSC1} alt="RSC illustration"/>),
      (<Image key={RSC2.src} src={RSC2} alt="RSC illustration"/>),
      (<Image key={RSC3.src} src={RSC3} alt="RSC illustration"/>),
      (<Image key={RSC4.src} src={RSC4} alt="RSC illustration"/>)
    ]} />
  </Column>
</TwoColumns>


<Notes>
React server components is probably one of the largest changes nextjs has pushed into the react ecosystem with nextjs 13. As I see it this is not something 100% new and more how it has been on other runtimes for a long time, but we have been focusing too much on creating SPAs so we have forgot about it. Doing the initial rendering on the server is how I think it should be, and then you just sprinkle some client side magic dust where you need it. This leads to faster applications and less javascript on the client which I think is a good thing. It also simplifies a lot when it comes to application infrastructure since you often can get rid of the whole BFF in a lot of scenarios, instead you can just get the data you need on the server and serve the finished HTML.

So how does it work? If you have a static page, you can easily make it all run and render on the server. In this scenario everything is considered to be a server components, which basically means it has no interaction.

A component is made a client component by adding "use client" to the top of the file, this basically tells nextjs that this component has interaction that needs to be dealt with. Note that the first render still happens on the server.

This "use client" directive sort of marks a border, and when you cross that border every component you define inside that border will be considered a client component. 

Note that I said every component you define inside. If you instead pass the component in as argument you can actually get to the scenario where you have a client component wrapping server components, which is very powerful and something that you probably want to use more often than not.

So let's look at some examples. First we have this simple demo where everything is running server side, and you can see on the log statment that it runs on the server, but nothing is visible in the browser log.

If we add a simple button to the page in a naive way everything has been turned to a client side component, but you can also notice that we log both on the server and on the client during hydration.

If we change it up and pass a button component in you will now see how we can mix and match server and client components, and this is what you want to do to get the best performance out of your application and as little javascript as possible on the client.
</Notes>
